<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>圆锥曲线入门</title>
      <link href="2021/08/28/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E5%85%A5%E9%97%A8/"/>
      <url>2021/08/28/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>给物理用的，数学爬开。</p><span id="more"></span><h1 id="定义">定义</h1><p>给定一点 P，一直线 l 以及一常数 <span class="math inline">\(e\)</span>（<span class="math inline">\(e &gt; 0\)</span>），则到 P 的距离与 l 距离之比为 <span class="math inline">\(e\)</span> 的点的轨迹是圆锥曲线。</p><ul><li>e = 1 抛物线</li><li>e &lt; 1 椭圆</li><li>e &gt; 1 双曲线</li></ul><p>P 为焦点，l 为准线， e 为偏心率，P 到 l 距离为焦准距，P 到曲线上一点的线段为焦半径。</p><h1 id="椭圆">椭圆</h1><h2 id="直角坐标">直角坐标</h2><p><span class="math inline">\(\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1\)</span>（焦点在 <span class="math inline">\(x\)</span> 轴上，<span class="math inline">\(a &gt; b &gt; 0\)</span>）</p><p><span class="math inline">\(c^2 = a^2 - b^2\)</span></p><p><span class="math inline">\(F_1(-c, 0), F_2(c, 0)\)</span></p><p><span class="math inline">\(e = \frac{c}{a}\)</span></p><p>准线 <span class="math inline">\(x = \pm\frac{a^2}{c}\)</span></p><h1 id="双曲线">双曲线</h1><h2 id="直角坐标-1">直角坐标</h2><p><span class="math inline">\(\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1\)</span></p><p><span class="math inline">\(c^2 = a^2 + b^2\)</span></p><p>渐近线 <span class="math inline">\(y = \pm\frac{b}{a}x\)</span></p><h1 id="抛物线">抛物线</h1><h2 id="直角坐标-2">直角坐标</h2><p><span class="math inline">\(y^2 = 2px\)</span></p><p><span class="math inline">\(F(\frac{p}{2}, 0)\)</span></p><p><span class="math inline">\(x = -\frac{p}{2}\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 圆锥曲线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学, 圆锥曲线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 学年第一学期</title>
      <link href="2021/01/30/2020-%E5%AD%A6%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F/"/>
      <url>2021/01/30/2020-%E5%AD%A6%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>期末考：2021.1.28 - 2021.1.30</p><p>结束了！</p><p>感觉这个学期什么都没干，总结先咕了。</p>]]></content>
      
      
      <categories>
          
          <category> 文化课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>退役</title>
      <link href="2020/08/13/%E9%80%80%E5%BD%B9/"/>
      <url>2020/08/13/%E9%80%80%E5%BD%B9/</url>
      
        <content type="html"><![CDATA[<p>大概会变成 whk blog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「JSOI2011」柠檬 题解</title>
      <link href="2020/08/09/%E3%80%8CJSOI2011%E3%80%8D%E6%9F%A0%E6%AA%AC-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/09/%E3%80%8CJSOI2011%E3%80%8D%E6%9F%A0%E6%AA%AC-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://www.luogu.com.cn/problem/P5504">Link</a></p><span id="more"></span><h1 id="题解">题解</h1><p>题目比较坑，有大小相同这一要求。</p><p>先想到的是一个 <span class="math inline">\(O(N^3)\)</span> 的 DP，设 <span class="math inline">\(dp_i\)</span> 表示到 <span class="math inline">\(i\)</span> 的最大数量，有转移方程 <span class="math inline">\(dp_i = \max\limits_{1 \le j \le i - 1}\{dp_j + \max\limits_{j + 1 \le k \le i}\{s_kcnt_{s_k}^2\}\}\)</span>，应该很好理解吧。</p><p>然后这个时间复杂度肯定过不去。</p><p>考虑优化，设 <span class="math inline">\(p_i\)</span> 表示到 <span class="math inline">\(i\)</span> 的转移点，如果 <span class="math inline">\(p_i\)</span> 与 <span class="math inline">\(i\)</span> 位置上的不同色，肯定不如同色的优。如果颜色不同我们一定可以向后修改 <span class="math inline">\(p_i\)</span> 使得同样是在这一段区间内 <span class="math inline">\(s_i\)</span> 出现的次数不变。</p><p>有了上面做铺垫，更改一下 <span class="math inline">\(dp\)</span> 的定义，要求该区间内选择的 <span class="math inline">\(s_0 = s_i\)</span>，同样能保证最优。</p><p>所以转移方程变成了这样：<span class="math inline">\(dp_i = \max\limits_{s_i = s_j}\{dp_{j - 1} + s_i(sum_i - sum_j + 1)^2\}\)</span>，去掉了枚举 <span class="math inline">\(s_0\)</span> 的那一循环，时间复杂度降至 <span class="math inline">\(O(n^2)\)</span>。</p><p><del>然后就不会了</del></p><p>对于相同的颜色 <span class="math inline">\(sum_i - sum_j + 1\)</span> 单调递增，则 <span class="math inline">\(s_i(sum_i - sum_j + 1)^2\)</span> 单调递增，于是有决策单调性，根据 FlashHu 大佬的话，导函数递增求最大值采用单调栈，我们用单调栈维护转移位置。</p><p>具体的，对于决策点 <span class="math inline">\(p_1, p_2\)</span>，若有 <span class="math inline">\(p_1 &lt; p_2\)</span> 且 <span class="math inline">\(f(p_1) &gt; f(p_2)\)</span>，则从 <span class="math inline">\(p_1\)</span> 转移，也就是说越靠后的转移转移点越靠前。</p><p>于是在单调栈上二分位置。</p><p>注意要分颜色讨论。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[N], b[N], sum[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dp[i - <span class="number">1</span>] + s[i] * t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = n, res = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Check</span>(ql, mid - sum[ql] + <span class="number">1</span>) &lt; <span class="built_in">Check</span>(qr, mid - sum[qr] + <span class="number">1</span>))</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid - <span class="number">1</span>, res = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="keyword">int</span>&gt; stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]), sum[i] = ++b[s[i]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (stk[s[i]].<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">BinarySearch</span>(stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">2</span>], stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">1</span>]) &lt;= <span class="built_in">BinarySearch</span>(stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">1</span>], i))</span><br><span class="line">      stk[s[i]].<span class="built_in">pop_back</span>();</span><br><span class="line">    stk[s[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (stk[s[i]].<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">BinarySearch</span>(stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">2</span>], stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">1</span>]) &lt;= sum[i])</span><br><span class="line">      stk[s[i]].<span class="built_in">pop_back</span>();</span><br><span class="line">    dp[i] = <span class="built_in">Check</span>(stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">1</span>], sum[i] - sum[stk[s[i]][stk[s[i]].<span class="built_in">size</span>() - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 决策单调性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HNOI2015」亚瑟王 题解</title>
      <link href="2020/08/08/%E3%80%8CHNOI2015%E3%80%8D%E4%BA%9A%E7%91%9F%E7%8E%8B-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/08/%E3%80%8CHNOI2015%E3%80%8D%E4%BA%9A%E7%91%9F%E7%8E%8B-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://loj.ac/problem/2112">Link</a></p><p>LOJ 的题面比 Luogu 的好看qwq</p><span id="more"></span><h1 id="题解">题解</h1><p>首先根据期望的线性性，最后的答案为 <span class="math inline">\(\sum\limits_{i = 1}^n a_i * f_i\)</span>，其中 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(i\)</span> 真实发动的概率。</p><p>为什么 <span class="math inline">\(f_i\)</span> 不等于 <span class="math inline">\(p_i\)</span> 呢，因为题中有限制：用了此张牌后进入下个回合，这时候每张牌的概率就变了。</p><p>那么考虑计算 <span class="math inline">\(f\)</span>，令 <span class="math inline">\(dp_{i, j}\)</span> 表示 <span class="math inline">\(r\)</span> 轮中在前 <span class="math inline">\(i\)</span> 张里面取了 <span class="math inline">\(j\)</span> 张的概率。先把 <span class="math inline">\(i = 1\)</span> 的算出来 <span class="math inline">\(dp_{1, 0}\)</span> 是 <span class="math inline">\(r\)</span> 轮中都没选到 <span class="math inline">\(1\)</span> 的概率为 <span class="math inline">\((1 - p_1)^r\)</span>，<span class="math inline">\(dp_{1, 1}\)</span> 与 <span class="math inline">\(f_1\)</span> 相等为 <span class="math inline">\(1 - (1 - p_1)^r\)</span>。</p><p>然后考虑 <span class="math inline">\(dp_{i, j}\)</span> 由什么得来，分类讨论： - 发动第 <span class="math inline">\(i\)</span> 张牌，那么概率为 <span class="math inline">\(dp_{i - 1, j - 1} * (1 - (1 - p_i)^{r - j - 1})\)</span>； - 如果不发动，那么概率为 <span class="math inline">\(dp_{i - 1, j} * (1 - p_i)^{r - j}\)</span>。</p><p>最终 <span class="math inline">\(dp_{i, j}\)</span> 为两个加起来。</p><p>那么 <span class="math inline">\(f_i\)</span> 就是 <span class="math inline">\(\sum\limits_{j = 0}^r dp_{i - 1, j} * (1 - (1 - p_i)^{r - j})\)</span>，意为在 <span class="math inline">\(j\)</span> 轮内发动过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">230</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">double</span> p[N], f[N];</span><br><span class="line"><span class="keyword">double</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FastPow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">      res = res * a;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>, &amp;p[i], &amp;d[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">FastPow</span>(<span class="number">1</span> - p[<span class="number">1</span>], m);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span> - <span class="built_in">FastPow</span>(<span class="number">1</span> - p[<span class="number">1</span>], m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(i, m); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j)</span><br><span class="line">          dp[i][j] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * (<span class="number">1</span> - <span class="built_in">FastPow</span>(<span class="number">1</span> - p[i], m - j + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (i != j)</span><br><span class="line">          dp[i][j] += dp[i - <span class="number">1</span>][j] * <span class="built_in">FastPow</span>(<span class="number">1</span> - p[i], m - j);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(i - <span class="number">1</span>, m); ++j)</span><br><span class="line">        f[i] += dp[i - <span class="number">1</span>][j] * (<span class="number">1</span> - <span class="built_in">FastPow</span>(<span class="number">1</span> - p[i], m - j));</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      ans += d[i] * f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 期望 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ZJOI2016」小星星 题解</title>
      <link href="2020/08/06/%E3%80%8CZJOI2016%E3%80%8D%E5%B0%8F%E6%98%9F%E6%98%9F-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/06/%E3%80%8CZJOI2016%E3%80%8D%E5%B0%8F%E6%98%9F%E6%98%9F-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://www.luogu.com.cn/problem/P3349">Li</a><a href="https://loj.ac/problem/2091">nk</a></p><span id="more"></span><h1 id="题解">题解</h1><p>看数据范围 <span class="math inline">\(n \le 17\)</span>，想到状态压缩，那必然是将点的状态作为 <span class="math inline">\(01\)</span> 串。</p><p>那和最终的答案有什么关系呢。</p><p>我们用 <span class="math inline">\(dp_{i}\)</span> 表示 <span class="math inline">\(i\)</span> 的子树内的方案数量，考虑到一定要有连边的要求，再加一维 <span class="math inline">\(j\)</span> 表示映射到的是哪一个点。</p><p>这时候会产生多个点映射到同一个点的情况，就是说原来的点集 <span class="math inline">\(S\)</span>，映射到的是 <span class="math inline">\(1 \sim S\)</span>，同理若是 <span class="math inline">\(S-1\)</span> 则映射到 <span class="math inline">\(1 \sim S-1\)</span>，那么我们枚举 <span class="math inline">\(S\)</span>，用容斥原理算出真正的 <span class="math inline">\(S\)</span>。</p><p>转移方程是 <span class="math inline">\(dp_{u, i} = \prod\limits_{v \in son(u)}\sum\limits_{j = 1}^n dp_{v, j}[\text{Unicom(u, v)}]\)</span>。</p><p>理解一下，要转移首先要保证两个点联通，然后枚举点映射到哪一个原图上的点。每棵子树是独立的，根据乘法原理取 <span class="math inline">\(\prod\)</span>。</p><p>然后套用一下容斥原理就好了，每次枚举选取/删除了哪些点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; g[N], h[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    dp[u][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : h[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs</span>(v, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        sum += dp[v][j] * (g[i][j] * vis[i] * vis[j]);</span><br><span class="line">      dp[u][i] *= sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    g[i].<span class="built_in">resize</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;u, &amp;v), --u, --v;</span><br><span class="line">    g[u][v] = g[v][u] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;u, &amp;v), --u, --v;</span><br><span class="line">    h[u].<span class="built_in">push_back</span>(v), h[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">1</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = n;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">        vis[i] = <span class="literal">true</span>, --cnt;</span><br><span class="line">    <span class="built_in">Dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      res += dp[<span class="number">0</span>][i];</span><br><span class="line">    ans += ((cnt &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>) * res;</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld\n&quot;, mask, res);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 树形动态规划 </category>
          
          <category> 容斥原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形动态规划 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「APIO2014」连珠线 题解</title>
      <link href="2020/08/05/%E3%80%8CAPIO2014%E3%80%8D%E8%BF%9E%E7%8F%A0%E7%BA%BF-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/05/%E3%80%8CAPIO2014%E3%80%8D%E8%BF%9E%E7%8F%A0%E7%BA%BF-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://www.luogu.com.cn/problem/P3647">Link</a></p><span id="more"></span><h1 id="题解">题解</h1><p>根据给出的连接方式，我们可以发现对于一条蓝线它的连接一定是从某节点开始向根节点方向一直到另一节点结束。</p><p>而且长度一定为偶数段（好像没什么用）。</p><p>如果只考虑以 <span class="math inline">\(1\)</span> 为根 <span class="math inline">\(u\)</span> 的子树的话，可以通过简单的动态规划解决。</p><p>设 <span class="math inline">\(dp_{i, 0/1}\)</span> 为点 <span class="math inline">\(i\)</span> 的子树下，<span class="math inline">\(i\)</span> 是否作为蓝线中点的最大得分，有转移方程： - <span class="math inline">\(dp_{u, 0} = \sum\limits_{v\in son(u)}\max\{dp_{v, 0}, dp_{v, 1} + w_{uv}\}\)</span> - <span class="math inline">\(dp_{u, 1} = dp_{u, 0} + \max\limits_{v\in son(u)}\{dp_{v, 0} + w_{uv} - \max\{dp_{v, 0}, dp_{v, 1} + w_{u, v}\}\}\)</span></p><p>然后再考虑子树外的贡献。</p><p>当一个节点变为根节点时，所要变化的是其原本父亲的 <span class="math inline">\(dp\)</span> 值与自己的。</p><p>如果当前节点是其父亲孩子中的最大值，那么此时父亲就无法从其转移只能从原先次大的转移而来，所以要记录次大值。</p><p>对于当前节点，新增了从其父亲来的贡献。</p><p>所以写的时候就先处理出 <span class="math inline">\(dp\)</span> 数组，然后记录下在这个过程中除掉某个孩子的值 <span class="math inline">\(f_{i, 0/1, j}\)</span> 表示 <span class="math inline">\(i\)</span> 的子树中除掉 <span class="math inline">\(j\)</span> 这个孩子的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, w, nxt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Edge</span>() : <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">w</span>(<span class="number">0</span>), <span class="built_in">nxt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _nxt) : <span class="built_in">v</span>(_v), <span class="built_in">w</span>(_w), <span class="built_in">nxt</span>(_nxt) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edge_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  e[++edge_cnt] = <span class="built_in">Edge</span>(v, w, head[u]);</span><br><span class="line">  head[u] = edge_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; f[N][<span class="number">2</span>], maxn[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dp[u][<span class="number">0</span>] = <span class="number">0</span>, dp[u][<span class="number">1</span>] = -INF;</span><br><span class="line">  <span class="keyword">int</span> maxn1 = -INF, maxn2 = -INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs1</span>(v, u);</span><br><span class="line">    dp[u][<span class="number">0</span>] += std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w);</span><br><span class="line">    <span class="keyword">if</span> (dp[v][<span class="number">0</span>] + w - std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w) &gt; maxn1)</span><br><span class="line">      maxn2 = maxn1, maxn1 = dp[v][<span class="number">0</span>] + w - std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dp[v][<span class="number">0</span>] + w - std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w) &gt; maxn2)</span><br><span class="line">      maxn2 = dp[v][<span class="number">0</span>] + w - std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w);</span><br><span class="line">  &#125;</span><br><span class="line">  dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>] + maxn1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    f[u][<span class="number">0</span>].<span class="built_in">push_back</span>(dp[u][<span class="number">0</span>] - std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w));</span><br><span class="line">    <span class="keyword">if</span> (dp[v][<span class="number">0</span>] + w - std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>] + w) == maxn1) &#123;</span><br><span class="line">      f[u][<span class="number">1</span>].<span class="built_in">push_back</span>(f[u][<span class="number">0</span>].<span class="built_in">back</span>() + maxn2);</span><br><span class="line">      maxn[u].<span class="built_in">push_back</span>(maxn2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f[u][<span class="number">1</span>].<span class="built_in">push_back</span>(f[u][<span class="number">0</span>].<span class="built_in">back</span>() + maxn1);</span><br><span class="line">      maxn[u].<span class="built_in">push_back</span>(maxn1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], cnt = <span class="number">0</span>; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    dp[u][<span class="number">0</span>] = f[u][<span class="number">0</span>][cnt], dp[u][<span class="number">1</span>] = f[u][<span class="number">1</span>][cnt];</span><br><span class="line">    <span class="keyword">if</span> (fa) &#123;</span><br><span class="line">      dp[u][<span class="number">0</span>] += std::<span class="built_in">max</span>(dp[fa][<span class="number">0</span>], dp[fa][<span class="number">1</span>] + l);</span><br><span class="line">      dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>] +</span><br><span class="line">                 std::<span class="built_in">max</span>(maxn[u][cnt],</span><br><span class="line">                          dp[fa][<span class="number">0</span>] + l - std::<span class="built_in">max</span>(dp[fa][<span class="number">0</span>], dp[fa][<span class="number">1</span>] + l));</span><br><span class="line">    &#125;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, dp[v][<span class="number">0</span>] + std::<span class="built_in">max</span>(dp[u][<span class="number">0</span>], dp[u][<span class="number">1</span>] + w));</span><br><span class="line">    <span class="built_in">Dfs2</span>(v, u, w);</span><br><span class="line">    ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, u, v, w; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    <span class="built_in">AddEdge</span>(u, v, w), <span class="built_in">AddEdge</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// for (int i =1; i &lt;= n; ++i)</span></span><br><span class="line">  <span class="comment">//   printf(&quot;&gt; %d %d\n&quot;, dp[i][0], dp[i][1]);</span></span><br><span class="line">  <span class="built_in">Dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 换根动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 换根 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOI2009」诗人小G 题解</title>
      <link href="2020/08/04/%E3%80%8CNOI2009%E3%80%8D%E8%AF%97%E4%BA%BA%E5%B0%8FG-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/04/%E3%80%8CNOI2009%E3%80%8D%E8%AF%97%E4%BA%BA%E5%B0%8FG-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://www.luogu.com.cn/problem/P1912">Link</a></p><span id="more"></span><h1 id="题解">题解</h1><p>还是一个很 naive 的 DP 方程：设 <span class="math inline">\(dp_i\)</span> 表示到第 <span class="math inline">\(i\)</span> 句的最小花费，<span class="math inline">\(sum_i\)</span> 是前 <span class="math inline">\(i\)</span> 句的总长度，得 <span class="math inline">\(dp_i = \min\limits_{j = 0}^{i - 1}\{dp_j + \mid sum_i - sum_j - 1 - L \mid^p\}\)</span></p><p>然后这个复杂度是 <span class="math inline">\(O(n^2)\)</span> 的，只有 <span class="math inline">\(30\)</span>（这个出题人一点都不良心）。</p><p>考虑怎么优化它。</p><p>特殊的，对于这一题，我们把 <span class="math inline">\(\mid sum_i - sum_j - 1 - L \mid\)</span> 单独提出来，那么可以去掉绝对值，得到一个单增的函数，显然可以二分最小值来转移。</p><p>推广到一半情况，那应该是转移方程形如 <span class="math inline">\(dp_i = \min / \max \limits_{j = 1}^{i - 1} dp_j + f_{i, j}\)</span>，记 <span class="math inline">\(i\)</span> 是从 <span class="math inline">\(p_i\)</span> 转移得来，有 <span class="math inline">\(p_i \le p_{i + 1}\)</span>。</p><p>这个叫做决策单调性，换句话说就是后面的 <span class="math inline">\(dp\)</span> 值由后面的转移而来，转移位置单调不降。</p><p>那有什么函数能满足决策单调性呢。</p><p>首先对于任意两个 <span class="math inline">\(dp\)</span> 的转移不能有公共值。形式化的，用 <span class="math inline">\(g_i(j)\)</span> 表示第 <span class="math inline">\(i\)</span> 个元素由第 <span class="math inline">\(j\)</span> 个转移而来的花费，<span class="math inline">\(\forall i, j\)</span>，<span class="math inline">\(\mid\text{Intersection}(i, j)\mid\le 1\)</span>，也就是只有至多一个交点。</p><p>严格的我也不会证明（捂脸</p><p>感性理解一下，如果有至少两个交点那么我们无法判断在当前区间内选择哪一个更优（虽然两个交点应该可以乱搞出转移区间的范围），但如果只有一个，我们就能确定在这个交点前选择哪一个在这个交点后选择哪一个。</p><p>然后引用 FlashHu 大佬的话： &gt; 如果导函数递增、求最大值（柠檬），或者导函数递减、求最小值，要用单调栈； &gt; &gt; 如果导函数递增、求最小值（本题），或者导函数递减、求最大值（Lightning Conductor），要用单调队列。</p><p>回到这一题，刚才已经得出了转移具有单调性那么用队列维护可以转移的区间，然后每次转移二分位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, l, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FastPow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">      res = res * a;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dp[j] + <span class="built_in">FastPow</span>(<span class="built_in">abs</span>(sum[i] - sum[j] - l - <span class="number">1</span>), p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, res;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Check</span>(mid, ql) &lt; <span class="built_in">Check</span>(mid, qr))</span><br><span class="line">      l = mid + <span class="number">1</span>, res = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> pos[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;l, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + <span class="built_in">strlen</span>(s[i] + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> he = <span class="number">1</span>, ta = <span class="number">1</span>;</span><br><span class="line">    q[he] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (he &lt; ta &amp;&amp; pos[he] &lt;= i)</span><br><span class="line">        ++he;</span><br><span class="line">      dp[i] = <span class="built_in">Check</span>(i, q[he]), pre[i] = q[he];</span><br><span class="line">      <span class="keyword">while</span> (he &lt; ta &amp;&amp; pos[ta - <span class="number">1</span>] &gt;= <span class="built_in">BinarySearch</span>(q[ta], i))</span><br><span class="line">        --ta;</span><br><span class="line">      pos[ta] = <span class="built_in">BinarySearch</span>(q[ta], i);</span><br><span class="line">      q[++ta] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] &gt; <span class="number">1e18</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Too hard to arrange\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.0Lf\n&quot;</span>, dp[n]);</span><br><span class="line">      <span class="keyword">int</span> tp = <span class="number">0</span>;</span><br><span class="line">      q[tp] = n;</span><br><span class="line">      <span class="keyword">int</span> i = n;</span><br><span class="line">      <span class="keyword">for</span> (; i; q[++tp] = i = pre[i])</span><br><span class="line">        ;</span><br><span class="line">      <span class="keyword">for</span> (; tp; --tp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = q[tp] + <span class="number">1</span>; i &lt; q[tp - <span class="number">1</span>]; ++i)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(s[i] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 决策单调性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】动态 DP &amp; 动态树分治 题解</title>
      <link href="2020/08/02/%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D%E5%8A%A8%E6%80%81-DP-%E5%8A%A8%E6%80%81%E6%A0%91%E5%88%86%E6%B2%BB-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/02/%E3%80%8C%E6%A8%A1%E6%9D%BF%E3%80%8D%E5%8A%A8%E6%80%81-DP-%E5%8A%A8%E6%80%81%E6%A0%91%E5%88%86%E6%B2%BB-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>蒟蒻太菜了，今天才学会 DDP。</p><h1 id="题目描述">题目描述</h1><p><a href="https://www.luogu.com.cn/problem/solution/P4719">Link</a></p><span id="more"></span><h1 id="题解">题解</h1><p>如果没有修改操作，那么就是一个入门组水平的树形 DP，设 <span class="math inline">\(dp_{u, 0/1}\)</span> 表示当 <span class="math inline">\(u\)</span> 选或不选时的最小花费。</p><p>然后考虑修改操作，naive 的想法是每次修改后暴力跑一遍树形 DP，这样的时间复杂度是 <span class="math inline">\(O(nm)\)</span> 的。</p><p>但是在每次修改的过程中很多值是不变的，会改变的值只有它到父亲的一条链上的点。</p><p>那就变成了一个链上的问题，考虑树剖。</p><p>那么原来的转移方程：</p><p><span class="math inline">\(dp_{u, 0} = \sum\limits_{v \in son(u)} \max\{dp_{v, 0}, dp_{v, 1}\}\)</span></p><p><span class="math inline">\(dp_{u, 1} = \sum\limits_{v \in son(u)} dp_{v, 0} + a_u\)</span></p><p>要对于轻重链分开讨论一下。</p><p>让 <span class="math inline">\(ldp_{u, 0/1}\)</span> 表示不考虑重儿子的情况，<span class="math inline">\(dp_{u, 0/1}\)</span> 表示考虑重儿子的情况。</p><p>为什么要分开讨论呢？</p><p>你树剖当然分开讨论不然要树剖干什么。</p><p>然后得到新的转移方程：</p><p><span class="math inline">\(ldp_{u, 0} = \sum\limits_{v \in son(u)} \max\{dp_{v, 0}, dp_{v, 1}\}[v \not = heavyson(u)]\)</span></p><p><span class="math inline">\(ldp_{u, 1} = dp_{u, 1} = \sum\limits_{v \in son(u)} dp_{v, 0}[v \not = heavyson(u)] + a_u\)</span></p><p><span class="math inline">\(dp\)</span> 的转移和上面是一样的。</p><p>树上问题转换成了链上问题，怎么维护相邻的值？</p><p>很自然想到线段树（动态 DP 常用方法），那我们要维护一个有结合律的东西。</p><p>回到上面的转移方程，想想有什么长得像，DP 转移还可以用什么方式表示。</p><p>下面这个矩阵运算顺序和上面的方程是一样的，但是我们所用的并不是一般的矩阵乘法那样的运算，而是取 <span class="math inline">\(\max\)</span>。</p><p><span class="math display">\[\begin{bmatrix}  dp_{v, 0} \\  dp_{v, 1}\end{bmatrix}\times\begin{bmatrix}  ldp_{u, 0} &amp; ldp_{u, 0} \\  ldp_{u, 1} &amp; -\infty\end{bmatrix}=\begin{bmatrix}  dp_{u, 0} \\  dp_{u, 1}\end{bmatrix}\]</span></p><p>那么我们重新定义一下矩阵乘法，令 <span class="math inline">\(C_{i, j} = \max\{a_{i, k} + b_{k, j}\}\)</span>。</p><p>然后展开就和上面的式子一样了。</p><p>所以我们用线段树维护上面那样的矩阵，但我好像不太会构造这东西的单位矩阵qwq，所以改了下线段树的写法。</p><p>对于一次修改操作，我们从需要修改的节点 <span class="math inline">\(u\)</span> 开始一路向上跳，对于一整条重链我们直接在线段树上统计答案，如果是轻链则暴力乘上当前节点的信息。</p><p>因为从点 <span class="math inline">\(u\)</span> 开始到根的重链不超过 <span class="math inline">\(\log n\)</span> 条，轻链长度为 <span class="math inline">\(1\)</span>，所以时间复杂度是 <span class="math inline">\(O(n \log^2 n)\)</span>。</p><p>下次试试看 LCT 来写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Edge</span>() : <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">nxt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _nxt) : <span class="built_in">v</span>(_v), <span class="built_in">nxt</span>(_nxt) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edge_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++edge_cnt] = <span class="built_in">Edge</span>(v, head[u]);</span><br><span class="line">  head[u] = edge_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heavy Light</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sze[N], son[N], in[N], ou[N], idx, tp[N], fa[N], bel[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  ::fa[u] = fa, sze[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs1</span>(v, u);</span><br><span class="line">    sze[u] += sze[v];</span><br><span class="line">    <span class="keyword">if</span> (sze[v] &gt; sze[son[u]])</span><br><span class="line">      son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">  ::tp[u] = tp, in[u] = ++idx, ou[tp] = idx, bel[idx] = u;</span><br><span class="line">  <span class="keyword">if</span> (son[u])</span><br><span class="line">    <span class="built_in">Dfs2</span>(son[u], u, tp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa || v == son[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs2</span>(v, u, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line"></span><br><span class="line">  Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    res.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k)</span><br><span class="line">          res.a[i][j] = std::<span class="built_in">max</span>(res.a[i][j], a[i][k] + rhs.a[k][j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">0</span>][<span class="number">1</span>], a[<span class="number">1</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">1</span>]); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>], ldp[N][<span class="number">2</span>];  <span class="comment">// both, only light</span></span><br><span class="line">Matrix mat[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls lc, l, mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs rc, mid + 1, r</span></span><br><span class="line"></span><br><span class="line">  Matrix t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123; t[rt] = t[lc] * t[rc]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      mat[bel[l]].a[<span class="number">0</span>][<span class="number">0</span>] = ldp[bel[l]][<span class="number">0</span>],</span><br><span class="line">      mat[bel[l]].a[<span class="number">0</span>][<span class="number">1</span>] = ldp[bel[l]][<span class="number">0</span>],</span><br><span class="line">      mat[bel[l]].a[<span class="number">1</span>][<span class="number">0</span>] = ldp[bel[l]][<span class="number">1</span>], mat[bel[l]].a[<span class="number">1</span>][<span class="number">1</span>] = -INF;</span><br><span class="line">      t[rt] = mat[bel[l]];</span><br><span class="line">      <span class="comment">// printf(&quot;%d: &quot;, rt), t[rt].Print();</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Build</span>(ls), <span class="built_in">Build</span>(rs);</span><br><span class="line">    <span class="built_in">PushUp</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">      <span class="keyword">return</span> t[rt] = mat[bel[l]], <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">      <span class="built_in">Update</span>(ls, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">Update</span>(rs, p);</span><br><span class="line">    <span class="built_in">PushUp</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Matrix <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">      <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d %d %d\n&quot;, rt, l, r, ql, qr);</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Query</span>(ls, ql, qr);</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Query</span>(rs, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Query</span>(ls, ql, qr) * <span class="built_in">Query</span>(rs, ql, qr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  ldp[u][<span class="number">1</span>] = a[u];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa[u] || v == son[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs3</span>(v);</span><br><span class="line">    ldp[u][<span class="number">0</span>] += std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">    ldp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[u][<span class="number">0</span>] = ldp[u][<span class="number">0</span>], dp[u][<span class="number">1</span>] = ldp[u][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">    <span class="built_in">Dfs3</span>(son[u]);</span><br><span class="line">    dp[u][<span class="number">0</span>] += std::<span class="built_in">max</span>(dp[son[u]][<span class="number">0</span>], dp[son[u]][<span class="number">1</span>]);</span><br><span class="line">    dp[u][<span class="number">1</span>] += dp[son[u]][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  mat[x].a[<span class="number">1</span>][<span class="number">0</span>] += k - a[x];</span><br><span class="line">  a[x] = k;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    <span class="keyword">int</span> _x = x;</span><br><span class="line">    x = tp[x];</span><br><span class="line">    Matrix pre = st.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[x], ou[x]);</span><br><span class="line">    <span class="comment">// printf(&quot;pre: &quot;), pre.Print();</span></span><br><span class="line">    st.<span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[_x]);</span><br><span class="line">    Matrix now = st.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[x], ou[x]);</span><br><span class="line">    <span class="comment">// printf(&quot;now: &quot;), now.Print();</span></span><br><span class="line">    x = fa[x];</span><br><span class="line">    mat[x].a[<span class="number">0</span>][<span class="number">0</span>] +=</span><br><span class="line">        std::<span class="built_in">max</span>(now.a[<span class="number">0</span>][<span class="number">0</span>], now.a[<span class="number">1</span>][<span class="number">0</span>]) - std::<span class="built_in">max</span>(pre.a[<span class="number">0</span>][<span class="number">0</span>], pre.a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    mat[x].a[<span class="number">0</span>][<span class="number">1</span>] = mat[x].a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    mat[x].a[<span class="number">1</span>][<span class="number">0</span>] += now.a[<span class="number">0</span>][<span class="number">0</span>] - pre.a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// printf(&quot;mat[%d]: &quot;, x), mat[x].Print();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Matrix res = st.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[<span class="number">1</span>], ou[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// res.Print();</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(res.a[<span class="number">0</span>][<span class="number">0</span>], res.a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="built_in">AddEdge</span>(u, v), <span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">Dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Dfs3</span>(<span class="number">1</span>);</span><br><span class="line">  st.<span class="built_in">Build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">Update</span>(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 动态动态规划 </category>
          
          <category> 树形动态规划 </category>
          
          <category> 数据结构 </category>
          
          <category> 树链剖分 </category>
          
          <category> 线段树 </category>
          
          <category> 矩阵乘法 </category>
          
          <category> 广义矩阵乘法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 动态动态规划 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> 广义矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOIP2018」保卫王国 题解</title>
      <link href="2020/08/02/%E3%80%8CNOIP2018%E3%80%8D%E4%BF%9D%E5%8D%AB%E7%8E%8B%E5%9B%BD-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/02/%E3%80%8CNOIP2018%E3%80%8D%E4%BF%9D%E5%8D%AB%E7%8E%8B%E5%9B%BD-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://loj.ac/problem/2955">Link</a></p><span id="more"></span><h1 id="题解">题解</h1><p>既然是刚学 DDP，那么从 DDP 来思考。</p><p>建议先做一下 <a href="https://www.luogu.com.cn/problem/solution/P4719">【模板】"动态 DP"&amp;动态树分治</a>。</p><p>然后这一题就是个板子题。</p><p>有结论 <strong>最小覆盖集 = 全集 - 最大独立集</strong>，然后把 Luogu 上动态 DP 的板子晚上一套稍微改一下写个主函数就过了（</p><p>关于 Luogu 的模板可以看以前的<a href="https://helloworld2005.top/2020/08/02/「模板」动态-DP-&amp;-动态树分治-题解/">博客</a>。</p><p>如果是强制不取点那么我们把当前点的权值设为 <span class="math inline">\(+\infty\)</span>，强制取为 <span class="math inline">\(-\infty\)</span>，即保证在最大独立集中出现/不出现，也就是在最小覆盖集中不出现/出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Edge</span>() : <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">nxt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _nxt) : <span class="built_in">v</span>(_v), <span class="built_in">nxt</span>(_nxt) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edge_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++edge_cnt] = <span class="built_in">Edge</span>(v, head[u]);</span><br><span class="line">  head[u] = edge_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heavy Light</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sze[N], son[N], in[N], ou[N], idx, tp[N], fa[N], bel[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  ::fa[u] = fa, sze[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs1</span>(v, u);</span><br><span class="line">    sze[u] += sze[v];</span><br><span class="line">    <span class="keyword">if</span> (sze[v] &gt; sze[son[u]])</span><br><span class="line">      son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">  ::tp[u] = tp, in[u] = ++idx, ou[tp] = idx, bel[idx] = u;</span><br><span class="line">  <span class="keyword">if</span> (son[u])</span><br><span class="line">    <span class="built_in">Dfs2</span>(son[u], u, tp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa || v == son[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs2</span>(v, u, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = -INF; &#125;</span><br><span class="line"></span><br><span class="line">  Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    res.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k)</span><br><span class="line">          res.a[i][j] = std::<span class="built_in">max</span>(res.a[i][j], a[i][k] + rhs.a[k][j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">0</span>][<span class="number">1</span>], a[<span class="number">1</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">1</span>]); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>], ldp[N][<span class="number">2</span>];  <span class="comment">// both, only light</span></span><br><span class="line">Matrix mat[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls lc, l, mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs rc, mid + 1, r</span></span><br><span class="line"></span><br><span class="line">  Matrix t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123; t[rt] = t[lc] * t[rc]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      mat[bel[l]].a[<span class="number">0</span>][<span class="number">0</span>] = ldp[bel[l]][<span class="number">0</span>],</span><br><span class="line">      mat[bel[l]].a[<span class="number">0</span>][<span class="number">1</span>] = ldp[bel[l]][<span class="number">0</span>],</span><br><span class="line">      mat[bel[l]].a[<span class="number">1</span>][<span class="number">0</span>] = ldp[bel[l]][<span class="number">1</span>], mat[bel[l]].a[<span class="number">1</span>][<span class="number">1</span>] = -INF;</span><br><span class="line">      t[rt] = mat[bel[l]];</span><br><span class="line">      <span class="comment">// printf(&quot;%d: &quot;, rt), t[rt].Print();</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Build</span>(ls), <span class="built_in">Build</span>(rs);</span><br><span class="line">    <span class="built_in">PushUp</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">      <span class="keyword">return</span> t[rt] = mat[bel[l]], <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">      <span class="built_in">Update</span>(ls, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">Update</span>(rs, p);</span><br><span class="line">    <span class="built_in">PushUp</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Matrix <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">      <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d %d %d\n&quot;, rt, l, r, ql, qr);</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Query</span>(ls, ql, qr);</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Query</span>(rs, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Query</span>(ls, ql, qr) * <span class="built_in">Query</span>(rs, ql, qr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; st;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp_&#123;u, 0&#125; dp_&#123;u, 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  ldp[u][<span class="number">1</span>] = a[u];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa[u] || v == son[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs3</span>(v);</span><br><span class="line">    ldp[u][<span class="number">0</span>] += std::<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">    ldp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[u][<span class="number">0</span>] = ldp[u][<span class="number">0</span>], dp[u][<span class="number">1</span>] = ldp[u][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">    <span class="built_in">Dfs3</span>(son[u]);</span><br><span class="line">    dp[u][<span class="number">0</span>] += std::<span class="built_in">max</span>(dp[son[u]][<span class="number">0</span>], dp[son[u]][<span class="number">1</span>]);</span><br><span class="line">    dp[u][<span class="number">1</span>] += dp[son[u]][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  mat[x].a[<span class="number">1</span>][<span class="number">0</span>] += k;  <span class="comment">// 注意一下这里不太一样因为不是改点权而是增加/减少点权</span></span><br><span class="line">  a[x] += k;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    <span class="keyword">int</span> _x = x;</span><br><span class="line">    x = tp[x];</span><br><span class="line">    Matrix pre = st.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[x], ou[x]);</span><br><span class="line">    <span class="comment">// printf(&quot;pre: &quot;), pre.Print();</span></span><br><span class="line">    st.<span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[_x]);</span><br><span class="line">    Matrix now = st.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[x], ou[x]);</span><br><span class="line">    <span class="comment">// printf(&quot;now: &quot;), now.Print();</span></span><br><span class="line">    x = fa[x];</span><br><span class="line">    mat[x].a[<span class="number">0</span>][<span class="number">0</span>] +=</span><br><span class="line">        std::<span class="built_in">max</span>(now.a[<span class="number">0</span>][<span class="number">0</span>], now.a[<span class="number">1</span>][<span class="number">0</span>]) - std::<span class="built_in">max</span>(pre.a[<span class="number">0</span>][<span class="number">0</span>], pre.a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    mat[x].a[<span class="number">0</span>][<span class="number">1</span>] = mat[x].a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    mat[x].a[<span class="number">1</span>][<span class="number">0</span>] += now.a[<span class="number">0</span>][<span class="number">0</span>] - pre.a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// printf(&quot;mat[%d]: &quot;, x), mat[x].Print();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Matrix res = st.<span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, in[<span class="number">1</span>], ou[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// res.Print();</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(res.a[<span class="number">0</span>][<span class="number">0</span>], res.a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> typ[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%s&quot;</span>, &amp;n, &amp;m, typ);</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), sum += a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="built_in">AddEdge</span>(u, v), <span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">Dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="built_in">Dfs3</span>(<span class="number">1</span>);</span><br><span class="line">  st.<span class="built_in">Build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;u, &amp;x, &amp;v, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">Update</span>(u, -INF);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">Update</span>(u, INF);</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">Update</span>(v, -INF);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">Update</span>(v, INF);</span><br><span class="line">    <span class="keyword">if</span> ((fa[u] == v || fa[v] == u) &amp;&amp; !x &amp;&amp; !y) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum - <span class="built_in">Query</span>() + (x ? <span class="number">0</span> : INF) + (y ? <span class="number">0</span> : INF));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">Update</span>(u, INF);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">Update</span>(u, -INF);</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">Update</span>(v, INF);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">Update</span>(v, -INF);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 动态动态规划 </category>
          
          <category> 树形动态规划 </category>
          
          <category> 数据结构 </category>
          
          <category> 树链剖分 </category>
          
          <category> 线段树 </category>
          
          <category> 矩阵乘法 </category>
          
          <category> 广义矩阵乘法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 动态动态规划 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> 广义矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SCOI2015」小凸玩密室 题解</title>
      <link href="2020/08/01/%E3%80%8CSCOI2015%E3%80%8D%E5%B0%8F%E5%87%B8%E7%8E%A9%E5%AF%86%E5%AE%A4-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/01/%E3%80%8CSCOI2015%E3%80%8D%E5%B0%8F%E5%87%B8%E7%8E%A9%E5%AF%86%E5%AE%A4-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意">题目大意</h1><p>丢个 <a href="https://loj.ac/problem/2009">Link</a></p><span id="more"></span><h1 id="题解">题解</h1><p>注意到题目中的遍历方式： - 联通； - 先点亮子树。</p><p>翻译成人话，就是从节点 <span class="math inline">\(u\)</span> 开始，走 <span class="math inline">\(u\)</span> 的子树，再到 <span class="math inline">\(u\)</span> 的父节点，走 <span class="math inline">\(u\)</span> 父节点的另一棵子树……</p><p>这样的话相当于基本确定了行走顺序。</p><p>对于每一步，如果前面状态确定了那么当前就是确定的，有两种： - <span class="math inline">\(u\)</span> 的 <span class="math inline">\(k\)</span> 级祖先； - <span class="math inline">\(u\)</span> 的 <span class="math inline">\(k\)</span> 级祖先的另一棵子树。</p><p>既然是一棵完全二叉树，总点数是 <span class="math inline">\(2 \times 10^5\)</span>，不难联想到和树高有关的 <span class="math inline">\(O(n \log n)\)</span> 算法。</p><p>设 <span class="math inline">\(dp_{1, i, j}\)</span> 表示第一种转移方式：当走完 <span class="math inline">\(i\)</span> 的子树后到 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(k\)</span> 级祖先的最小花费。</p><p>设 <span class="math inline">\(dp_{2, i, j}\)</span> 表示第二种转移方式：当走完 <span class="math inline">\(i\)</span> 的字数后到 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(k\)</span> 级祖先的另一棵子树的最小花费。</p><p>然后分类讨论一下： - 如果当前点是叶子节点，那么没有转移； - 如果当前点只有左儿子，那么当前节点 <span class="math inline">\(dp\)</span> 的值就是左儿子的 <span class="math inline">\(dp\)</span> 值加上转移所要的花费； - 如果当前点两个孩子都有，那么把先走左儿子和先走右儿子的都算出来取个 <span class="math inline">\(\min\)</span>。</p><p>然后计算答案，枚举以哪个节点作为起始节点，然后可以暴力跳父亲 <span class="math inline">\(\log\)</span> 次计算答案。</p><p>注意对是否有兄弟节点分类讨论。</p><p>所以我们维护一下节点 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(k\)</span> 级祖先的距离 <span class="math inline">\(dis_{u, k}\)</span>，然后这样转移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pat</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;  <span class="comment">// u 的 k 级祖先</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>)) &lt;= u)</span><br><span class="line">    <span class="keyword">return</span> u &gt;&gt; k;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Another</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;  <span class="comment">// u 的 k 级祖先的另一个孩子</span></span><br><span class="line">  <span class="keyword">return</span> (u &gt;&gt; (k - <span class="number">1</span>)) ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ~<span class="built_in">Pat</span>(i, j); ++j) &#123;</span><br><span class="line">    dp1[i][j] = dp2[i][j] = INF;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt;&lt; <span class="number">1</span>) &gt; n) &#123;</span><br><span class="line">      dp1[i][j] = dis[i][j] * a[<span class="built_in">Pat</span>(i, j)];</span><br><span class="line">      dp2[i][j] = (dis[i][j] + dis[<span class="built_in">Another</span>(i, j)][<span class="number">1</span>]) * a[<span class="built_in">Another</span>(i, j)];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &gt; n) &#123;</span><br><span class="line">      dp1[i][j] = dp1[i &lt;&lt; <span class="number">1</span>][j + <span class="number">1</span>] + dis[i &lt;&lt; <span class="number">1</span>][<span class="number">1</span>] * a[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">      dp2[i][j] = dp2[i &lt;&lt; <span class="number">1</span>][j + <span class="number">1</span>] + dis[i &lt;&lt; <span class="number">1</span>][<span class="number">1</span>] * a[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp1[i][j] = std::<span class="built_in">min</span>(dp2[i &lt;&lt; <span class="number">1</span>][<span class="number">1</span>] + dp1[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][j + <span class="number">1</span>] +</span><br><span class="line">                               dis[i &lt;&lt; <span class="number">1</span>][<span class="number">1</span>] * a[i &lt;&lt; <span class="number">1</span>],</span><br><span class="line">                           dp2[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][<span class="number">1</span>] + dp1[i &lt;&lt; <span class="number">1</span>][j + <span class="number">1</span>] +</span><br><span class="line">                               dis[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][<span class="number">1</span>] * a[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">      dp2[i][j] = std::<span class="built_in">min</span>(dp2[i &lt;&lt; <span class="number">1</span>][<span class="number">1</span>] + dp2[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][j + <span class="number">1</span>] +</span><br><span class="line">                               dis[i &lt;&lt; <span class="number">1</span>][<span class="number">1</span>] * a[i &lt;&lt; <span class="number">1</span>],</span><br><span class="line">                           dp2[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][<span class="number">1</span>] + dp2[i &lt;&lt; <span class="number">1</span>][j + <span class="number">1</span>] +</span><br><span class="line">                               dis[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][<span class="number">1</span>] * a[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后是统计答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> res = dp1[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">Pat</span>(i, <span class="number">1</span>), qwq = i; ~j; qwq = j, j = <span class="built_in">Pat</span>(j, <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Another</span>(qwq, <span class="number">1</span>) &lt;= n)</span><br><span class="line">      res += dis[(<span class="built_in">Another</span>(qwq, <span class="number">1</span>))][<span class="number">1</span>] * a[<span class="built_in">Another</span>(qwq, <span class="number">1</span>)] +</span><br><span class="line">             dp1[<span class="built_in">Another</span>(qwq, <span class="number">1</span>)][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      res += dis[j][<span class="number">1</span>] * a[<span class="built_in">Pat</span>(j, <span class="number">1</span>)];</span><br><span class="line">  &#125;</span><br><span class="line">  ans = std::<span class="built_in">min</span>(ans, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是做完了。</p><p>主要是要发现题目中隐含的确定顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 树形动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树 </tag>
            
            <tag> 树形动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task Supercomputer 题解</title>
      <link href="2020/07/31/Task-Supercomputer-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/31/Task-Supercomputer-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>好难啊qwq，蒟蒻完全不会斜率优化。</p><h1 id="题目大意">题目大意</h1><p><a href="https://www.luogu.com.cn/problem/P3571">Link</a></p><p><a href="https://szkopul.edu.pl/problemset/problem/e9ycK_efBDBt4aPs-QeqYpwR/site/?key=statement#">原题面</a></p><span id="more"></span><h1 id="题解">题解</h1><p><span class="math inline">\(n, q &lt;= 10^6\)</span> 提示离线，我们肯定无法做到对于每个 <span class="math inline">\(k\)</span> 去 <span class="math inline">\(O(1)\)</span> 在线询问。</p><!-- ## 引理1： 对于前 $i$ 层我们最少需要 $i$ 次首先证明不可能少于 $i$ 次，这个很显然，每次必须先要选父亲。然后证明 $i$ 次一定可行， --><p>最优方案肯定是先用 <span class="math inline">\(x\)</span> 步解决前 <span class="math inline">\(x\)</span> 层，然后剩下部分每次能选满 <span class="math inline">\(k\)</span> 个。</p><p>显然无法用少于 <span class="math inline">\(x\)</span> 步解决前 <span class="math inline">\(x\)</span> 层因为每次要先选择父亲节点。</p><p>那为什么 <span class="math inline">\(x\)</span> 步一定可以选完呢？</p><p><a href="https://www.luogu.com.cn/blog/league/solution-p3571">看这里</a></p><p>然后设计状态和转移： - <span class="math inline">\(dp_i\)</span> 表示当 <span class="math inline">\(k = i\)</span> 时最小需要的次数，<span class="math inline">\(s_i\)</span> 表示深度大于 <span class="math inline">\(i\)</span> 的节点数量； - <span class="math inline">\(dp_i = \max\{j + \lceil \frac{s_j}{i}\rceil\}\)</span></p><p>至于为什么是 <span class="math inline">\(\max\)</span> 不是 <span class="math inline">\(\min\)</span>，在所有的 <span class="math inline">\(j\)</span> 中充斥着大量不可行的方案，只有一种是合法的，因为我们要保证后面的每次都取满 <span class="math inline">\(i\)</span>，这样的 <span class="math inline">\(i\)</span> 显然只有一个。取另外的会导致偏小。</p><p>形式化来讲，就是对于 <span class="math inline">\(j, k, j &gt; k\)</span>，可以做到用 <span class="math inline">\(j\)</span> 次访问完前 <span class="math inline">\(j\)</span> 层和用 <span class="math inline">\(k\)</span> 次访问完前 <span class="math inline">\(k\)</span> 层。那么：如果我们无法做到用 <span class="math inline">\(j - k\)</span> 次完成 <span class="math inline">\(j\)</span> 到 <span class="math inline">\(k\)</span> 层的访问，那么：</p><p><span class="math inline">\(\lceil \frac{s_k - s_j}{i}\rceil &gt; j - k\)</span></p><p>随便搞搞得</p><p><span class="math inline">\(k + \lceil \frac{s_k}{i}\rceil &gt; j + \lceil \frac{s_j}{i} \rceil\)</span></p><p>我们要的是 <span class="math inline">\(k\)</span>，所以用 <span class="math inline">\(\max\)</span>。</p><p>直接转移是 <span class="math inline">\(O(n^2)\)</span> 的，</p><p>注意到转移方程里有 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，想到斜率优化。</p><p><span class="math inline">\(dp_i = \max\{j + \lceil \frac{s_j}{i}\rceil\}\)</span></p><p>对于 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(k\)</span>，有：</p><p><span class="math inline">\(\begin{aligned} j + \lceil \frac{s_j}{i}\rceil &amp;&gt; k + \lceil \frac{s_k}{i} \rceil\\ ij + s_j &amp;&gt; ik + s_k\\ i(j - k) &amp;&gt; s_k - s_j\\ i &amp;&lt; \frac{s_j - s_k}{j - k} \end{aligned}\)</span></p><p>然后就可以斜率优化了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * (s[x] - s[y]) / (s - y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Edge</span>() : <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">nxt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _nxt) : <span class="built_in">v</span>(_v), <span class="built_in">nxt</span>(_nxt) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], edge_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++edge_cnt] = <span class="built_in">Edge</span>(v, head[u]);</span><br><span class="line">  head[u] = edge_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N], cnt[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * (s[x] - s[y]) / (x - y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">int</span> maxque = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;que[i]), maxque = std::<span class="built_in">max</span>(maxque, que[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u), v = i;</span><br><span class="line">    <span class="built_in">AddEdge</span>(u, v), <span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> maxdep = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    ++cnt[dep[i]], maxdep = std::<span class="built_in">max</span>(maxdep, dep[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = maxdep; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    s[i] = s[i + <span class="number">1</span>] + cnt[i + <span class="number">1</span>];</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">resize</span>(N);</span><br><span class="line">  <span class="keyword">int</span> hd = <span class="number">0</span>, tl = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxdep; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (hd &lt; tl &amp;&amp; <span class="built_in">Slope</span>(q[tl - <span class="number">1</span>], q[tl]) &lt;= <span class="built_in">Slope</span>(q[tl], i))</span><br><span class="line">      --tl;</span><br><span class="line">    q[++tl] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxque; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (hd &lt; tl &amp;&amp; i * q[hd] + s[q[hd]] &lt;= i * q[hd + <span class="number">1</span>] + s[q[hd + <span class="number">1</span>]])</span><br><span class="line">      ++hd;</span><br><span class="line">    dp[i] = q[hd] + <span class="built_in">ceil</span>(<span class="number">1.0</span> * s[q[hd]] / i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dp[que[i]]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过有两个玄学问题qwq</p><p>一个是为什么这一题 Slope 那里返回值为 int 也能过，还有一个是为什么我写的 deque 挂了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxdep; ++i) &#123;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp;</span><br><span class="line">         <span class="built_in">Slope</span>(q[q.<span class="built_in">size</span>() - <span class="number">2</span>], q[q.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;= <span class="built_in">Slope</span>(q[q.<span class="built_in">size</span>() - <span class="number">1</span>], i)))</span><br><span class="line">    q.<span class="built_in">pop_back</span>();</span><br><span class="line">  q.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxque; ++i) &#123;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; i * q[<span class="number">0</span>] + s[q[<span class="number">0</span>]] &lt;= i * q[<span class="number">1</span>] + s[q[<span class="number">1</span>]])</span><br><span class="line">  q.<span class="built_in">pop_front</span>();</span><br><span class="line">  dp[i] = q[<span class="number">0</span>] + <span class="built_in">ceil</span>(<span class="number">1.0</span> * s[q[<span class="number">0</span>]] / i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 斜率优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SDOI2017」数字表格 题解</title>
      <link href="2020/07/22/%E3%80%8CSDOI2017%E3%80%8D%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/22/%E3%80%8CSDOI2017%E3%80%8D%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意">题目大意</h1><p>求 <span class="math display">\[\prod \limits_{i = 1}^{n} \prod \limits_{i = 1}^{m} f_{\gcd(i, j)}\]</span> 其中 <span class="math inline">\(f_i\)</span> 为斐波那契数列。</p><span id="more"></span><h1 id="题解">题解</h1><p>一看就先把 <span class="math inline">\(\gcd\)</span> 提出来，老套路题了。</p><p>不妨设 <span class="math inline">\(n \le m\)</span>，则</p><p><span class="math display">\[\begin{aligned}  原式 &amp;= \prod \limits_{d = 1}^{n} \prod \limits_{i = 1}^{\lfloor \frac{n}{d} \rfloor} \prod \limits_{i = 1}^{\lfloor \frac{m}{d} \rfloor} f_d^{[\gcd(i, j) = 1]}\\  &amp;= \prod \limits_{d = 1}^n f_d^{\sum \limits_{i = 1}^{\lfloor \frac{n}{d} \rfloor}\sum \limits_{i = 1}^{\lfloor \frac{m}{d} \rfloor}[\gcd(i, j) = 1]}\\  &amp;= \prod \limits_{d = 1}^n f_d^{\sum\limits_{g = 1}^n \mu(g)\lfloor\frac{n}{dg}\rfloor\lfloor\frac{m}{dg}\rfloor}\\  &amp;= \prod \limits_{k = 1}^n(\prod \limits_{d = 1}^nf_d^{\mu({\frac{k}{d}})})^{\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor}\end{aligned}\]</span></p><p>然后右上角那两个 <span class="math inline">\(\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor\)</span> 可以整除分块，剩下的问题是如何处理出 <span class="math inline">\(\prod \limits_{d = 1}^nf_d^{\mu({\frac{k}{d}})}\)</span>。</p><p>令 <span class="math inline">\(F(k) = \prod \limits_{d = 1}^nf_d^{\mu({\frac{k}{d}})}\)</span></p><p>因为需要数论分块，考虑前缀积。</p><p>这一块有参考 <a href="https://www.luogu.com.cn/blog/lx-2003/mobius-inversion">rqy 的 blog</a>。</p><p>和线性递推逆元类似的方法，我们可以得到 <span class="math inline">\(F(k)\)</span> 的前缀积以及其逆元。我参考了 <a href="https://www.luogu.com.cn/blog/qwaszx/solution-p3704">qwaszx 的博客</a>。</p><!--留个锅以后补--><p>然后要注意的细节是快速幂里面是 <span class="math inline">\((n / l) * (m / l) \bmod{p - 1}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> pri[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i])</span><br><span class="line">      pri[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt; N; ++j) &#123;</span><br><span class="line">      vis[i * pri[j]] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FastPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % MOD)</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">      res = <span class="number">1ll</span> * res * a % MOD;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N], g[N];</span><br><span class="line"><span class="keyword">int</span> mf[N], invf[N];  <span class="comment">// pre-multiF invF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = N - <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">1</span>] = mf[<span class="number">1</span>] = invf[<span class="number">0</span>] = invf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % MOD, mf[i] = <span class="number">1ll</span> * mf[i - <span class="number">1</span>] * f[i] % MOD;</span><br><span class="line">  <span class="keyword">int</span> t = <span class="built_in">FastPow</span>(mf[n], MOD - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">    invf[i] = <span class="number">1ll</span> * t * mf[i - <span class="number">1</span>] % MOD, t = <span class="number">1ll</span> * t * f[i] % MOD;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)  <span class="comment">// 只含有前 i 个质因子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n / pri[i]; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">      f[j * pri[i]] = <span class="number">1ll</span> * f[j * pri[i]] * invf[j] % MOD;</span><br><span class="line">      invf[j * pri[i]] = <span class="number">1ll</span> * invf[j * pri[i]] * f[j] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    f[i] = <span class="number">1ll</span> * f[i] * f[i - <span class="number">1</span>] % MOD,</span><br><span class="line">    invf[i] = <span class="number">1ll</span> * invf[i] * invf[i - <span class="number">1</span>] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="built_in">Sieve</span>();</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, res = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">      std::<span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">      r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">      res = (<span class="number">1ll</span> * res *</span><br><span class="line">             <span class="built_in">FastPow</span>(<span class="number">1ll</span> * f[r] * invf[l - <span class="number">1</span>] % MOD, <span class="number">1ll</span> * (n / l) * (m / l) % (MOD - <span class="number">1</span>))) %</span><br><span class="line">            MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就这代码跑了 Luogu 第 7？？？要是我再卡卡常。。。</p><p><span class="math inline">\(O(n \log \log n)\)</span> 好啊！</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
          <category> 莫比乌斯反演 </category>
          
          <category> 狄利克雷卷积 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 狄利克雷卷积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Miller Rabin 与 Pollar-Rho</title>
      <link href="2020/07/21/Miller-Rabin-%E4%B8%8E-Pollar-Rho/"/>
      <url>2020/07/21/Miller-Rabin-%E4%B8%8E-Pollar-Rho/</url>
      
        <content type="html"><![CDATA[<h1 id="miller-rabin-质数判定">Miller Rabin 质数判定</h1><h2 id="费马小定理">费马小定理</h2><p>众所周知</p><p>当 <span class="math inline">\(p\)</span> 是质数， 对于任意 <span class="math inline">\(a\)</span>，有 <span class="math display">\[a^{p - 1} \equiv 1 \pmod{p}\]</span></p><h2 id="二次剩余">二次剩余</h2><p>当 <span class="math inline">\(p\)</span> 是质数，对于 <span class="math inline">\(x \in (0, p)\)</span>，关于 <span class="math inline">\(x\)</span> 的方程 <span class="math inline">\(x^2 \equiv 1 \pmod{p}\)</span> 的解为 <span class="math inline">\(x = 1 \ or \ p\)</span>。</p><p>两个逆定理同样成立。</p><p><strong>下面开始正题</strong></p><p>对于任意 <span class="math inline">\(a\)</span>，令 <span class="math inline">\(p - 1 = 2^qm, m = 2n + 1, n \in \mathbb{N}\)</span>： - 根据费马小定理，如果 <span class="math inline">\(a^{p - 1} \not\equiv 1 \pmod{p}\)</span>，那么 <span class="math inline">\(p\)</span> 不是质数； - 根据二次剩余，如果 <span class="math inline">\(a^{p} \equiv 1 \pmod{p}\)</span> 但 <span class="math inline">\(a^{p - 1} \equiv 1 \pmod{p}\)</span>，那 <span class="math inline">\(p\)</span> 不是质数。</p><p>那么我们不断选择 <span class="math inline">\(a\)</span> 进行检验。</p><p>如果 <span class="math inline">\(p\)</span> 是质数，那么通过以上两个测试的概率为 <span class="math inline">\(1\)</span>；如果 <span class="math inline">\(p\)</span> 不是质数，那么通过以上两个测试的概率为 <span class="math inline">\(\frac{1}{4}\)</span>。</p><p>只要取足够多个 <span class="math inline">\(a\)</span>，那么就能将错误率降低到可以接受的范围内。</p><p>如果是 <code>int</code> 范围那么 <span class="math inline">\(10\)</span> 次左右可以保证正确，如果是 <code>long long</code> 那么 <span class="math inline">\(20\)</span> 次。</p><p>或者还有一种方法直接令 <span class="math inline">\(a\)</span> 为前 <span class="math inline">\(10 \sim 20\)</span> 个质数，至少 <code>long long</code> 范围内没有什么问题。</p><span id="more"></span><h1 id="pollar-rho-分解质因数">Pollar-Rho 分解质因数</h1><p>名字来源可能是因为长得像 <span class="math inline">\(\rho\)</span>？</p><p>网上的大部分资料都没怎么看懂，上来就是式子。</p><p>那我先放一张图。</p><figure><img data-src="https://i.loli.net/2020/07/21/mjsvFXi1rCVczKN.png" alt="pollar-rho.png" /><figcaption aria-hidden="true">pollar-rho.png</figcaption></figure><p><del>好了讲完了</del> 我是看了这张图突然明白的qwq</p><!-- 我们考虑什么时候待分解的数 $p$ 能被 $n$ 整除。 --><p>考虑在什么情况下能找到 <span class="math inline">\(p\)</span> 的一个拆分。</p><p><del>这谁想的出来嘛</del></p><p>给出一个伪随机序列生成方式</p><p><span class="math display">\[a_i \equiv a_{i - 1}^2 + b \pmod{p}\]</span></p><p>这个数列的每一项都由前一项决定，且值域为 <span class="math inline">\([0, p)\)</span>，那么数列 <span class="math inline">\(a\)</span> 必然有循环节，也就是上面那个环。</p><p>我们把 <span class="math inline">\(p\)</span> 换成 <span class="math inline">\(q\)</span>，再生成一遍这个序列，又得到一个循环节。</p><p>设两次的循环节长度分别为 <span class="math inline">\(m\)</span>、<span class="math inline">\(n\)</span>，如果 <span class="math inline">\(m \not = n\)</span>，那么说明我们找到了两个数 <span class="math inline">\(m, n\)</span> 使得 <span class="math inline">\(\gcd(m - n, p) \not = 1 \ or \ p\)</span>。</p><p>至于具体实现：</p><p>算出第一个序列，找到循环节长度 <span class="math inline">\(m\)</span>；找到一个 <span class="math inline">\(q\)</span>， 算出第二个序列，找到循环节长度 <span class="math inline">\(n\)</span>。 然后分三类： - <span class="math inline">\(\gcd = 1 \ or \ p\)</span>：再找 <span class="math inline">\(q\)</span>； - <span class="math inline">\(\gcd \not = 1 \ or \ p\)</span>：找到一个因子 <span class="math inline">\(\gcd\)</span>。</p><p>于是我们完成了一次拆分。</p><p>下面来分析复杂度。</p><p>根据<a href="https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA/2715290?fr=aladdin">生日</a><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C">悖论</a>，可得在第一个序列中出现相同数的期望长度为 <span class="math inline">\(\sqrt p\)</span>，在第二个序列中出现相同数的期望长度为 <span class="math inline">\(\sqrt q\)</span>。</p><p>那么只要枚举 <span class="math inline">\(\sqrt q\)</span> 个数就可以找到一种拆分。</p><p>如果令 <span class="math inline">\(q\)</span> 为 <span class="math inline">\(p\)</span> 的最小因子，那么期望只要枚举 <span class="math inline">\(p^{\frac{1}{4}}\)</span> 次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 质数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共价大爷游长沙</title>
      <link href="2020/07/17/%E5%85%B1%E4%BB%B7%E5%A4%A7%E7%88%B7%E6%B8%B8%E9%95%BF%E6%B2%99/"/>
      <url>2020/07/17/%E5%85%B1%E4%BB%B7%E5%A4%A7%E7%88%B7%E6%B8%B8%E9%95%BF%E6%B2%99/</url>
      
        <content type="html"><![CDATA[<p>先膜毛爷爷。</p><h1 id="题目描述">题目描述</h1><p><a href="https://uoj.ac/problem/207">UOJ#207. 共价大爷游长沙</a></p><p>给出一棵动态的树，有一个集合 <span class="math inline">\(S\)</span>，每次询问集合中的所有点相连的路径是否一定经过 <span class="math inline">\((x, y)\)</span>。</p><p>四种操作： - <span class="math inline">\(\text{opt} = 1, x, y, u, v\)</span>：删除边 <span class="math inline">\((x, y)\)</span>，增加边 <span class="math inline">\((u, v)\)</span>； - <span class="math inline">\(\text{opt} = 2, x, y\)</span>：在集合 <span class="math inline">\(S\)</span> 中加入 <span class="math inline">\((x, y)\)</span>； - <span class="math inline">\(\text{opt} = 3, x\)</span>：删除第 <span class="math inline">\(x\)</span> 个加入集合 <span class="math inline">\(S\)</span> 的点对； - <span class="math inline">\(\text{opt} = 4, x, y\)</span>：询问集合中的所有点相连的路径是否一定经过 <span class="math inline">\((x, y)\)</span>。</p><span id="more"></span><table><thead><tr class="header"><th>测试点编号</th><th><span class="math inline">\(n\)</span></th><th><span class="math inline">\(m\)</span></th><th><span class="math inline">\(\text{type}\)</span></th><th>限制</th></tr></thead><tbody><tr class="odd"><td>1</td><td><span class="math inline">\(n \le 100\)</span></td><td><span class="math inline">\(m \le 100\)</span></td><td>1, 2, 3, 4</td><td></td></tr><tr class="even"><td>2, 3</td><td><span class="math inline">\(n \le 100000\)</span></td><td><span class="math inline">\(m \le 300000\)</span></td><td>2, 4</td><td></td></tr><tr class="odd"><td>4, 5</td><td></td><td></td><td>2, 3, 4</td><td></td></tr><tr class="even"><td>6, 7</td><td></td><td></td><td>1, 2, 3, 4</td><td><span class="math inline">\(\mid S\mid \le 10\)</span></td></tr><tr class="odd"><td>8, 9, 10</td><td></td><td></td><td>1, 2, 3, 4</td><td></td></tr></tbody></table><h1 id="题解">题解</h1><p>对于测试点 1，可以暴力。可以用一个 set 维护边的信息，对于加边删边直接用 set 的 insert 和 erase，每次暴力遍历 s 中的所有点对走一遍看是否经过边 <span class="math inline">\((x, y)\)</span>。</p><p>对于测试点 2、3、4、5，因为没有加边删边操作，所以每次将加入点对 <span class="math inline">\((x, y)\)</span> 这条链上的值 <span class="math inline">\(+1\)</span>，每次查询时判断 <span class="math inline">\((x, y)\)</span> 上的和是否为 <span class="math inline">\(\mid S \mid\)</span>，正确性显然。因为不改变树的形态，而且维护的是一条链的信息，所以树链剖分和 LCT 应该都可以。</p><p>对于测试点 6、7，可以用 LCT，因为 <span class="math inline">\(\mid S \mid \le 10\)</span>，所以在删边的时候可以暴力枚举 <span class="math inline">\(10\)</span> 种的变化。</p><p>暂时只会 <span class="math inline">\(70\)</span> 分吧。</p><p>哦我好像想到正解了 (Update 2020.7.17 20点左右)。</p><p>考虑当 <span class="math inline">\(u\)</span> 为根的时候，如果所有路径都经过 <span class="math inline">\((u, v)\)</span>，那么对于 <span class="math inline">\(S\)</span> 中的所有点对 <span class="math inline">\((x, y)\)</span>，其路径有且仅有一个端点在以 <span class="math inline">\(x\)</span> 为根 <span class="math inline">\(y\)</span> 的子树中。</p><p>那么如何判断？</p><p>假设现在有一种数据类型 <span class="math inline">\(\text{Type}\)</span>，它支持一个操作 <span class="math inline">\(\text{operator}\)</span> 满足 <span class="math inline">\(x \ \ \text{operator} \ \ x = 0\)</span> 和 <span class="math inline">\(0 \ \ \text{operator} \ \ x = x\)</span>，且有一个 <span class="math inline">\(\text{Type} \ \ ans\)</span>，那么在加进边的时候，把 <span class="math inline">\(ans \ \ \text{operator}\ \ rnd()\)</span>，删边时 <span class="math inline">\(\text{operator}\)</span> 回去。那么可以记录整棵树的 <span class="math inline">\(ans\)</span>，每次询问以 <span class="math inline">\(x\)</span> 为根 <span class="math inline">\(y\)</span> 的子树的值，如果满足所有点对 <span class="math inline">\((u, v)\)</span> 都经过 <span class="math inline">\((x, y)\)</span> 这条边，那么该值应该等于 <span class="math inline">\(ans\)</span>。</p><p>我选择用了异或，如果加减法混合用应该也可以。</p><p>维护子树信息，<del>Top Tree</del>。</p><p>LCT 维护的是实链的信息，对于除了 Access 和 Link 的操作并不会改变虚边的信息。</p><p>如果只考虑实链，那么 PushUp 是这样写： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sze[x] = sze[ch[x][<span class="number">0</span>]] ^ sze[ch[x][<span class="number">1</span>]] ^ v[x]; &#125;</span><br></pre></td></tr></table></figure></p><p>然后考虑虚链。</p><p>用 <span class="math inline">\(sze_x\)</span> 表示 <span class="math inline">\(x\)</span> 的子树虚链信息，<span class="math inline">\(v_x\)</span> 表示 <span class="math inline">\(x\)</span> 的信息。</p><ul><li><p>Access(x) 操作：断 <span class="math inline">\(ch_{x, 1}\)</span>，连 <span class="math inline">\(i\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">    <span class="built_in">Splay</span>(x);</span><br><span class="line">    v[x] ^= sze[ch[x][<span class="number">1</span>]], v[x] ^= sze[ch[x][<span class="number">1</span>] = i];</span><br><span class="line">    <span class="built_in">PushUp</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Link(x, y) 操作：连 <span class="math inline">\(y\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="built_in">Split</span>(x, y), fa[x] = y, v[y] ^= sze[x], <span class="built_in">PushUp</span>(y); &#125;</span><br></pre></td></tr></table></figure></p></li></ul><p><del>挺显然的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N], rev[N], sze[N], v[N];</span><br><span class="line">  <span class="keyword">int</span> stk[N];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sze[x] = sze[ch[x][<span class="number">0</span>]] ^ sze[ch[x][<span class="number">1</span>]] ^ v[x]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; std::<span class="built_in">swap</span>(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]), rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">Reverse</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (ch[x][<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">Reverse</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">      rev[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], c = <span class="built_in">Child</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsRoot</span>(y)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch[z][<span class="number">0</span>] == y)</span><br><span class="line">        ch[z][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ch[z][<span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x] = z, fa[y] = x, fa[ch[x][c ^ <span class="number">1</span>]] = y;</span><br><span class="line">    ch[y][c] = ch[x][c ^ <span class="number">1</span>], ch[x][c ^ <span class="number">1</span>] = y;</span><br><span class="line">    <span class="built_in">PushUp</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; !<span class="built_in">IsRoot</span>(i); i = fa[i])</span><br><span class="line">      stk[++top] = fa[i];</span><br><span class="line">    <span class="keyword">while</span> (top)</span><br><span class="line">      <span class="built_in">PushDown</span>(stk[top--]);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsRoot</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = fa[x];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">IsRoot</span>(y)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Child</span>(x) ^ <span class="built_in">Child</span>(y))</span><br><span class="line">          <span class="built_in">Rotate</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">Rotate</span>(y);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PushUp</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">      <span class="built_in">Splay</span>(x);</span><br><span class="line">      v[x] ^= sze[ch[x][<span class="number">1</span>]], v[x] ^= sze[ch[x][<span class="number">1</span>] = i];</span><br><span class="line">      <span class="built_in">PushUp</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MakeRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="built_in">Access</span>(x), <span class="built_in">Splay</span>(x), <span class="built_in">Reverse</span>(x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="built_in">MakeRoot</span>(x), <span class="built_in">Access</span>(y), <span class="built_in">Splay</span>(y); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="built_in">Split</span>(x, y), fa[x] = y, v[y] ^= sze[x], <span class="built_in">PushUp</span>(y); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Split</span>(x, y);</span><br><span class="line">    ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PushUp</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Split</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> v[y];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Access</span>(x), <span class="built_in">Splay</span>(x);</span><br><span class="line">    v[x] ^= y;</span><br><span class="line">    <span class="built_in">PushUp</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; lct;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Edge</span>() : <span class="built_in">u</span>(<span class="number">0</span>), <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">w</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) : <span class="built_in">u</span>(_u), <span class="built_in">v</span>(_v), <span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="keyword">int</span> edge_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, u, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    lct.<span class="built_in">Link</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> opt, x, y, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;u, &amp;v);</span><br><span class="line">      lct.<span class="built_in">Cut</span>(x, y), lct.<span class="built_in">Link</span>(u, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">int</span> z = <span class="built_in">rnd</span>() % (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">      e[++edge_cnt] = <span class="built_in">Edge</span>(x, y, z);</span><br><span class="line">      lct.<span class="built_in">Update</span>(x, z), lct.<span class="built_in">Update</span>(y, z);</span><br><span class="line">      ans ^= z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      lct.<span class="built_in">Update</span>(e[x].u, e[x].w), lct.<span class="built_in">Update</span>(e[x].v, e[x].w);</span><br><span class="line">      ans ^= e[x].w;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lct.<span class="built_in">Query</span>(x, y) == ans ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> LCT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬家了</title>
      <link href="2020/07/15/%E6%90%AC%E5%AE%B6%E4%BA%86/"/>
      <url>2020/07/15/%E6%90%AC%E5%AE%B6%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>又回到了 Hexo，原博文暂时存在 <a href="https://old.helloworld2005.top">Wordpress</a> 上。</p><p>这个博客算是一个新的起点吧qwq</p><p>会好好写的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Draft</title>
      <link href="2000/01/01/Draft/"/>
      <url>2000/01/01/Draft/</url>
      
        <content type="html"><![CDATA[<p>草稿</p><span id="more"></span><p><span class="math inline">\(\sum \limits_{d \mid n} \mu(d) = [n = 1]\)</span></p><p><span class="math inline">\(\mu * I = e\)</span></p><hr /><p><span class="math inline">\(\sum \limits_{d \mid n} \varphi(d) = n\)</span></p><p><span class="math inline">\(\varphi(d) * I = id\)</span></p><hr /><p><span class="math inline">\(\sum \limits_{d \mid n} d \mu(\frac{n}{d}) = \varphi(n)\)</span></p><p><span class="math inline">\(\mu * id = \varphi\)</span></p><hr /><p><span class="math inline">\(\sum \limits_{d \mid n} \mu(d) = [n = 1]\)</span></p><p><span class="math inline">\([\gcd(i, j) = 1] = \sum \limits_{d \mid i, d \mid j}\mu(d)\)</span></p><hr /><p><span class="math inline">\(\sum\limits_{i = 1}^{n} \sum \limits_{j = 1}^{m} \sum \limits_{d \mid i, d \mid j} \mu(d) = \sum \limits_{d = 1}^{n} \mu(d) \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor\)</span></p><hr /><p><span class="math inline">\(B_t(x) \equiv B_{t - 1}(x)(2 - A(x)B_{t - 1}(x)) \pmod{x^{2^t}}\)</span></p><hr /><p><del><span class="math inline">\(f_i(x) = f(x) \frac{w_i}{x - x_i}\)</span></del></p><p><del><span class="math inline">\(F(x) = f(x)\sum\limits_{i = 0}^n \frac{w_i}{x - x_i} y_i\)</span></del></p><p><span class="math inline">\(P_n(x) = y_i\frac{(x - x2)(x - x3) \cdots (x - x_n)(x - x_{n + 1})}{(x_1 - x_2)(x_1 - x_3)\cdots(x_1 - x_n)(x_1 - x_{n + 1})}\)</span></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
